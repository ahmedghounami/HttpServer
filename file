



#include "server.hpp"

int main()
{
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
    {
        std::cerr << "Socket creation failed\n";
        return 1;
    }

    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        std::cerr << "Bind failed\n";
        return 1;
    }

    if (listen(server_fd, 128) < 0)
    {
        std::cerr << "Listen failed\n";
        return 1;
    }

    std::cout << "Server running on port " << PORT << "\n";

    struct pollfd fd;
    fd.fd = server_fd;
    fd.events = POLLIN;

    std::vector<pollfd> clients_fds;

    clients_fds.push_back(fd);

    while (true)
    {
        int ret = poll(&clients_fds[0], clients_fds.size(), 5000);
        if (ret < 0)
        {
            std::cerr << "Poll failed\n";
            continue;
        }
        else if (ret == 0)
        {
            std::cerr << "No data, timeout\n";
            continue;
        }

        if (clients_fds[0].revents & POLLIN)
        {
            sockaddr_in client_addr;
            socklen_t client_len = sizeof(client_addr);
            int client_sock = accept(server_fd, (struct sockaddr *)&client_addr, &client_len);
            std::cout << "new connection---------------: " << client_sock << std::endl;
            sleep(1);
            if (client_sock < 0)
                continue;

            struct pollfd newfd;
            newfd.fd = client_sock;
            newfd.events = POLLIN;

            clients_fds.push_back(newfd);
            clients[client_sock] = client_info();
        }

        // for (int i = 1; i < clients_fds.size(); i++)
        // {
        std::string filename = "file.png";
        std::ofstream file(filename);

        if (file.good())
        {
            std::cerr << "File opened successfully\n";
        }
        else
        {
            std::cerr << "File open failed\n";
            return 1;
        }


        std::string boundary;
        if (clients_fds[1].revents & POLLIN)
        {
            std::string request_data;

            while (true)
            {
                char buffer[1024];
                int data = recv(clients_fds[1].fd, buffer, sizeof(buffer) - 1, 0);

                if (data < 0)
                    continue; // Ignore empty reads

                buffer[data] = '\0';    // Properly terminate string
                request_data.append(buffer, data);

                if (request_data.find("\r\n\r\n") != std::string::npos)
                {
                    // get boundary
                    std::string boundary_start = "boundary=";
                    size_t boundary_start_pos = request_data.find(boundary_start);
                    size_t boundary_end_pos = request_data.find("\r\n", boundary_start_pos);
                    boundary = request_data.substr(boundary_start_pos + boundary_start.length(), boundary_end_pos - boundary_start_pos - boundary_start.length());
                    request_data = request_data.substr(request_data.find("Content-Type: image/png") + 27);
                }
                // data
                //
                // ---------------------------------------------7e0d1b6e0b8f--
                size_t pos = request_data.find(boundary + "--");
                if (pos != std::string::npos)
                {
                    request_data = request_data.substr(0, pos - 4);
                    // std::cerr << request_data;
                    file << request_data;
                    file.close();
                    request_data.clear();
                    exit(0);
                }

                file << request_data;
                request_data.clear();
            
            }
        }
        // }
    }
    for (int i = 1; i < clients_fds.size(); i++)
        close(clients_fds[i].fd);
    return 0;
}
